searchState.loadedDescShard("idalib_sys", 0, "Set #start_ea, #end_ea to 0\nCompare two range_t instances, based on the start_ea\nIs ‘ea’ in the address range?\nIs every ea in ‘r’ also in this range_t?\nSynthesized copy constructor.\nSynthesized destructor.\nIs the size of the range_t &lt;= 0?\n&lt; end_ea excluded\nEnsure that the range_t includes ‘ea’\nReturns the argument unchanged.\nReturns the argument unchanged.\nAssign the range_t to the intersection between the range_t …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSynthesized move constructor.\nIs there an ea in ‘r’ that is also in this range_t?\nPrint the range_t. \\param buf the output buffer \\param …\n\\file lines.hpp\nGet #end_ea - #start_ea\n&lt; start_ea included\nGet flags value for address ‘ea’. The byte value is …\nDoes flag denote start of an instruction?\nDoes flag denote start of data?\nAppend to an indented comment. Creates a new comment if …\nSet an indented comment. \\param ea      linear address …\nGet entry point address by its ordinal \\param ord  ordinal …\nGet ordinal number of an entry point. \\param idx  internal …\nGet number of entry points\nHas SP-analysis been performed?\nCalculate target of a thunk function. \\param pfn   pointer …\nSynthesized copy constructor.\nSynthesized copy constructor.\nDoes function return?\nSynthesized destructor.\nSynthesized destructor.\nFlow chart block types\n&lt; conditional return block\n&lt; external noreturn block (does not belong to the function)\n&lt; block passes execution past the function end\n&lt; external normal block\n&lt; block ends with indirect jump\n&lt; noreturn block\n&lt; normal block\n&lt; return block\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA function is a set of continuous ranges of addresses with …\ngdl graph interface - includes only functions required to …\nGet pointer to function structure by address. \\param ea  …\nGet ordinal number of a function. \\param ea  any address …\nGet total number of functions in the program\nGet pointer to function structure by number. \\param n  …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs a far function?\nHelper class to lock a function pointer so it stays valid\nSynthesized move constructor.\nNeeds prolog analysis?\nInformation about a basic block of a \\ref qflow_chart_t\nA flow chart for a function, or a set of address ranges\n&lt; list of arguments (indexes into vars)\n&lt; function body, must be a block\n&lt; map of instruction boundaries. use \\ref get_boundaries\nFunction argument\nFunction argument list\n&lt; Switch cases: values and instructions\n&lt; “catch all”, if present, must be the last element. &lt; …\nCompound statement (curly braces)\nCtree item: expression. Depending on the exact expression …\nDecompiled function. Decompilation result is kept here.\nSmart pointer to objects derived from ::qrefcnt_obj_t\nCtree item: statement. Depending on the exact statement …\nBasic ctree item. This is an abstract class (but we don’…\nSwitch statement\nThrow statement\nC++ Try statement. This structure is also used to …\nSynthesized destructor.\nSynthesized destructor.\n&lt; address that corresponds to the item. may be BADADDR\n&lt; ea-&gt;insn map. use \\ref get_eamap\n&lt; function entry address\n&lt; \\ref EXFL_\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; number of lines in the declaration area\n&lt; an index in cfunc_t::treeitems. &lt; meaningful only after …\nCheck that your plugin is compatible with hex-rays …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs C++ wind statement? (not part of the C++ language) MSVC …\n&lt; label number. -1 means no label. items of the expression …\n&lt; maturity level\n&lt; underlying microcode\n&lt; Maximal switch value and number format\n&lt; new state number (internal, MSVC related)\n&lt; user-defined number formats.\n&lt; old state number (internal, MSVC related)\n&lt; item type\n&lt; reference count to this object. use cfuncptr_t\n&lt; current cfunc_t state. see \\ref CFS_\n&lt; decompilation output: function text. use \\ref …\nStop working with hex-rays decompiler.\n&lt; vector of pointers to citem_t objects (nodes …\n&lt; expression type. must be carefully maintained\n&lt; user-defined comments.\n&lt; user-defined item flags \\ref CIT_\n&lt; user-defined labels.\n&lt; user-defined union field selections.\nProcess everything in the queues and return true. \\return …\n&lt; stack\n&lt; cdecl + ellipsis\n&lt; stack, purged (x86), first args are in regs …\n&lt; (Go) arguments and return value reg/stack depending on …\n&lt; (Go) arguments and return value in stack\n&lt; this value is invalid\n\\defgroup CM_CC_ Calling convention @{\n&lt; stack, purged, reverse order of args\n&lt; reserved; used for internal needs\n&lt; usercall: locations of all arguments &lt; and the return …\n&lt; ::CM_CC_SPECIAL with ellipsis\n&lt; Equal to ::CM_CC_SPECIAL, but with purged stack\n&lt; This is NOT a cc! Mark of __spoil record &lt; the low …\n&lt; stack, purged\n&lt; (Swift) arguments and return values in registers …\n&lt; stack, purged (x86), first arg is in reg …\n&lt; unknown calling convention\n&lt; function without arguments &lt; if has other cc and argnum …\n\\defgroup CM_ptr Default pointer size @{\n&lt; large:   code=far, data=far\n&lt; medium:  code=far, data=near\n@} \\defgroup CM_M_ Model @{\n&lt; compact: code=near, data=far\n&lt; small:   code=near, data=near (or unknown if CM_UNKNOWN)\n&lt; near 2 bytes, far 4 bytes\n&lt; near 4 bytes, far 6 bytes\n&lt; if sizeof(int)&gt;2: near 8 bytes, far 8 bytes\n&lt; if sizeof(int)&lt;=2: near 1 byte, far 2 bytes\n&lt; unknown\n&lt; Borland C++\n&lt; Delphi\n&lt; GNU C++\n\\defgroup COMP_ Compiler IDs @{\n&lt; Visual C++\n&lt; Unknown\n&lt; uncertain compiler id\n&lt; Visual Age C++\n&lt; Watcom C++\n&lt; memory model and calling convention (see \\ref CM_) &lt; see …\nInformation about the target compiler\n&lt; default alignment for structures\n&lt; AIX ar library\n&lt; Linux a.out (AOUT)\n&lt; ar library\n&lt; Binary File\n&lt; Common Object File Format (COFF)\n&lt; MS DOS COM File\n&lt; MS DOS COM File\n&lt; MS DOS Driver\n&lt; Executable and Linkable Format (ELF)\n&lt; MS DOS EXE File\n&lt; MS DOS EXE File\n&lt; Intel Hex Object File\n&lt; Linear Executable (LE)\n&lt; file is loaded using LOADER DLL\n&lt; Linear Executable (LX)\n&lt; Mac OS X Mach-O\n&lt; Mediatek Firmware Image\n&lt; MOS Technology Hex Object File\n&lt; Netware Loadable Module (NLM)\n&lt; Object Module Format\n&lt; Library of OMF Modules\n&lt; Portable Executable (PE)\n&lt; PalmPilot program file\n&lt; Sony Playstation PSX object file\n&lt; Motorola SREC (S-record)\n&lt; Watcom DOS32 Extender (W32RUN)\n&lt; New Executable (NE)\n&lt; ZIP file (this file is never loaded to IDA database)\nKnown input file formats (kept in \\inf{filetype}):\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; compiler id (see \\ref COMP_)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&lt; sizeof(bool)\n&lt; sizeof(enum)\n&lt; sizeof(int)\n&lt; long\n&lt; longdouble (if different from \\ph{tbyte_size})\n&lt; longlong\n&lt; short\n&lt; An indirect memory reference that uses a register and &lt; …\n&lt; An immediate far code reference (inter-segment)\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type.\n&lt; processor specific type. &lt; (there can be more processor …\n&lt; An immediate Value (constant).\n&lt; A direct memory reference to a data item. &lt; Use this …\n&lt; An immediate near code reference (intra-segment)\n&lt; An indirect memory reference that uses a register: [reg] …\n&lt; General Register (al,ax,es,ds…).\n&lt; No Operand.\nSynthesized copy constructor.\nSynthesized destructor.\nFind a user-defined plugin and optionally load it. \\param …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSynthesized move constructor.\nA plugin is a module in the plugins subdirectory that can …\nRun a loaded plugin with the specified argument. \\param …\nGet input file md5\nGet input file sha256\nGet size of input file in bytes\nGet address from the list at ‘idx’\nGet index of the name in the list \\warning returns the …\nGet name using idx\nGet number of names in the list\nIs the name included into the name list?\n\\name Work with publicness of a name @{\n\\name Work with weak names. @{\n&lt; virtual address pointed or used by the operand. &lt; …\n&lt; processor dependent field\nCurrent segment base paragraph. Initialized by the kernel.\nType of operand value (see \\ref dt_). This is the type of …\nLinear address of the instruction. Initialized by the …\n&lt; \\ref OF_\n&lt; \\ref INSN_\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; IBM PC: segment selector value  …\nStructure to hold information about an instruction. …\n&lt; processor dependent field\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVirtual address of the instruction (address within the …\nInternal code of instruction (only for canonical insns - …\n&lt; IBM PC: segment register number …\nNumber of operand (0,1,2). Initialized once at the start …\nOffset of operand value from the instruction start (0 …\nSame as #offb (some operands have 2 numeric values used to …\nOperand of an instruction. \\ingroup operands_t This …\n@}\nThis structure is defined for your convenience only\nThis structure is defined for your convenience only\nThis structure is defined for your convenience only\n&lt; array of operands\n\\defgroup operands Operands Work with instruction operands\n&lt; number of register phrase (::o_phrase,::o_displ). &lt; you …\n&lt; number of register (::o_reg)\n&lt; processor dependent field\nSize of instruction in bytes. The analyzer should put here …\n\\name Special flags The following fields are used only in …\n&lt; This field may be used as you want.\nType of operand (see \\ref o_)\n&lt; operand value (::o_imm) or &lt; outer displacement …\n\\name Byte size Number of 8bit bytes required to hold one …\nHelper function to get the delay slot instruction\nSynthesized destructor.\nReturns the argument unchanged.\nGet the instruction features (combination of \\ref CF_)\nGet the instruction name\nGet default segment bitness \\retval 2  #PR_DEFSEG64 …\n@}\nGet register information - useful for registers like al, …\nGet the stack variable scaling factor. Useful for …\nCalls <code>U::from(self)</code>.\nDoes the given value specify a valid instruction for this …\nDescribes a processor module (IDP). An IDP file may have …\nGet size of long double\nGet number of address bits\nGet number of address bytes\n\\name Segment flag: ORG directive See #SFL_COMORG @{\nSynthesized copy constructor.\nSynthesized copy constructor.\nSynthesized destructor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet pointer to segment by its name. If there are several …\nGet number of segments\nGet pointer to segment by its number. \\warning Obsoleted …\nGet pointer to segment by linear address. \\param ea  …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs a 16-bit segment?\nIs a 32-bit segment?\nIs a 64-bit segment?\n\\name Segment flag: debugger segment See #SFL_DEBUG @{\nEphemeral segments are not analyzed automatically (no …\n\\name Segment flag: header segment See #SFL_HEADER @{\n\\name Segment flag: hide segment type See #SFL_HIDETYPE @{\n\\name Segment flag: loader segment See #SFL_LOADER @{\n\\name Segment flag: hidden See #SFL_HIDDEN @{\nHelper class to lock a segment pointer so it stays valid\nSynthesized move constructor.\nConstructor\n\\name Segment flag: orgbase See #SFL_OBOK @{\nDescribes a program segment\nUpdate segment information. You must call this function …\nRebuild the string list.\nClear the string list.\nGet number of elements in the string list. The list will …\nIf the instruction at ‘ea’ looks like an alignment …\nIs the instruction the end of a basic block?\nIs the instruction a “call”?\nIs the instruction an indirect jump?\n@}\nGet start of next defined item. \\param ea     begin search …\nGet start of previous defined item. \\param ea     begin …\nSynthesized copy constructor.\nCODE xref types\n&lt; Informational &lt; (a derived java class references its base\n&lt; Offset &lt; The reference uses ‘offset’ of data &lt; …\n&lt; Read access\n&lt; Reference to enum member (symbolic constant)\n&lt; Text (for forced operands only) &lt; Name of data is used …\n&lt; Unknown – for compatibility with old &lt; versions. …\n&lt; Write access\nDATA xref types\nSynthesized destructor.\nGet first xref from the given address (store in #to)\nGet xref to given address (store in #from)\n&lt; Call Far &lt; This xref creates a function at the &lt; …\n&lt; Call Near &lt; This xref creates a function at the &lt; …\n&lt; Ordinary flow: used to specify execution &lt; flow to the …\n&lt; Jump Far\n&lt; Jump Near\n&lt; unknown – for compatibility with old &lt; versions. …\n&lt; User specified (obsolete)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n&lt; the referencing address - filled by first_to(),next_to()\nDoes ‘ea’ have references from outside of ‘pfn’?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&lt; is code reference (::cref_t)? &lt; otherwise it is a data …\nSynthesized move constructor.\nSynthesized default constructor.\n&lt; the referenced address - filled by first_from(), …\n&lt; type of the last returned reference (::cref_t &amp; ::dref_t)\n&lt; is user defined xref? otherwise defined by ida\nStructure to enumerate all xrefs. This structure provides …\n\\name Helper functions Should not be called directly! @{")